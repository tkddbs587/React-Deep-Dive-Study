### 렌더링은 어떻게 일어나는가?

브라우저에서의 렌더링이란 쉽게 말해 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을의미한다.

그리고 리액트에도 렌더링이라는 과정이 존재한다. 리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를만드는 과정을 의미한다.

**리액트의 렌더링이란?**

리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

**리액트의 렌더링이 일어나는 이유**

우선 리액트에서 렌더링이 언제 발생하는지 알아보자.

1. **최초 렌더링**
   사용자가 처음 애플리케이션에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.
2. **리렌더링**
   리렌더링은 처음 애플리케이션에 진입했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다.
   리렌더링이 발생하는 경우는 다음과 같다.

- 클래스형 컴포넌트의 setstate가 실행되는 경우
- 클래스형 컴포넌트의 forceUpdate가 실행되는 경우
- 함수형 컴포넌트의 useState의 setter 함수가 실행되는 경우
- 함수형 컴포넌트의 useReducer의 dispatch가 실행되는 경우
- 컴포넌트의 key props가 변경되는 경우
- props가 변경되는 경우
- 부모 컴포넌트가 렌더링될 경우

리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다.

리렌더링이 발생하면 current 트리와 worklnProgress 트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별해야 하는데, 이 두 트리 사이에서 같은 컴포넌트인지를 구별하는 값이 바로 key다.

이 변경 사항을 구별하는 작업은 리렌더링이 필요한 컴포넌트를 최소화해야 하므로 반드시 필요한 작업이다.

key가 존재한다면 두 트리 사이에서 통일한 key를 가지고 있는 컴포넌트는 이를 기준으로 구별할 수 있지만,이

key가 없다면 단순히 파이버 내부의 sibling 인덱스만을 기준으로 판단하게 된다.

![alt text](image.png)

- 부모 List가 리렌더링 되어도 Child는 memo로 선언돼 있으므로 리렌더링이 발생하지 않는다. 결국 `<Child/>`는 `<Child key={index} />`와 동일하게 작동한다.
- 만약 `<Child key={Math.random()} />` 으로 랜덤한 키 값이 주어진다면 리렌더링이 일어날 때마다 sibling 컴포넌트를 명확히 구분할 수 없어 Child가 memo로 선언됐더라도 매번 리렌더링이 일어나게 된다. 즉, key의 변화는 리렌더링을 야기한다.

리액트에서 렌더링이 일어나는 경우는 앞에서 나열한 시나리오뿐이다.

![alt text](<image 1.png>)

- 위와 같이 useState 등으로 관리되지 않는 단순한 변수는 제아무리 변경된다 하더라도 리렌더링을 발생시키지 않아 변경된 값을 렌더링된 DOM에서 확인할 수 없다.

---

### **리액트의 렌더링 프로세스**

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.

만약 여기서 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 클래스형 컴포넌트의 경우에는 클래스 내부의 render() 함수를 실행하게 되고, 함수형 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출한 뒤에, 그 결과물을 저장한다.

렌더링 결과물은 JSX 문법으로 구성돼 있고, 이것이 자바스크립트로 컴파일되면서 React.createElement()를 호출하는 구문으로 변환된다.

여기서 createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환한다. 예제를 살펴보자.

![alt text](<image 2.png>)

- 위 JSX 문법은 다음과 같은 React.createElement를 호출해서 변환된다.

![alt text](<image 3.png>)

- 반환된 결과물은 다음과 같다.

![alt text](<image 4.png>)

렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.

이렇게 계산하는 과정을 바로 리액트 파이버에서 다뤘던 리액트의 재조정(Reconciliation)이라고 한다.

이러한 재조정 과정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

주목해야 할 것은 리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다는 것이다.

---

### **렌더와 커밋**

**렌더 단계(Render Phase)**

컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다.

즉, 렌더링 프로세스에서 컴포넌트를 실행해(render() 또는 return) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다.

비교하는 것은 크게 세 가지로 type, props, key다. 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해둔다.

**커밋 단계(Commit Phase)**

렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

리액트가 커밋 단계에서 DOM을 업데이트한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다.

그다음, 생명주기 개념이 있는 클래스형 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출하고, 함수형 컴포넌트에서는 useLayoutEffect 훅을 호출한다.

중요한 사실은 **리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니라는 것**이다. 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다.

![alt text](<image 5.png>)

---

**일반적인 렌더링 시나리오 살펴보기**

지금까지 언급한 내용을 바탕으로 예제 코드를 살펴보면서 리액트의 렌더링이 어떻게 일어나는지 살펴보자.

![alt text](<image 6.png>)

- 사용자가 B 컴포넌트의 버튼을 눌러 counter 변수를 업데이트 했을 때, 리액트에서는 다음과 같은 순서로 렌더링이 일어난다.

![alt text](<image 7.png>)

- 즉, 컴포넌트를 렌더링하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트에 영향을 미친다.
- 상위 컴포넌트, 특히 루트에서 무언가 렌더링을 발생시키는 작업이 일어난다는 것은 하위 모든 컴포넌트의 리렌더링을 발생 시킨다는 뜻이다.
- 이 작업이 하위 컴포넌트에 변경 사항을 야기하지 않더라도 리액트는 이와 상관없이 어쨌든 리렌더링 작업을 요청하고 비교 작업을 수행하므로 그만큼의 시간과 노력이 소요된다.

만약 D 컴포넌트에 memo를 추가하면 어떻게 될까?

![alt text](<image 8.png>)

![alt text](<image 9.png>)

- B 컴포넌트에서 상태값이 변경됐음에도 memo로 래핑돼 있어 렌더링이 일어나지 않는다
- 렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된 것이다.
